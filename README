# Project Kanban Board

## Overview

A Kanban board application for managing projects, stages, tasks, and subtasks. This application provides a visual way to track project progress from conception to completion. The frontend is built with React using Vite, offering a fast and modern development experience, and it communicates with a backend server to persist data.

## Features

*   **Project Management:**
    *   Create new projects with names and descriptions.
    *   View a list of all existing projects.
    *   Navigate to a detailed Kanban board view for each project.
    *   Delete projects (which also removes all associated stages, tasks, and subtasks).
*   **Stage Management (within a Project Board):**
    *   Create new stages (e.g., "To Do", "In Progress", "Done").
    *   Rename existing stages.
    *   Reorder stages within the project board.
    *   Delete stages (which also removes all associated tasks and subtasks).
*   **Task Management (within Stages):**
    *   Create new tasks with content, assignee, start date, and end date.
    *   Edit task details through a modal form.
    *   Move tasks between different stages.
    *   Reorder tasks within a single stage.
    *   Delete tasks (which also removes all associated subtasks).
*   **Subtask Management (within Tasks):**
    *   Create new subtasks with content.
    *   Edit subtask content inline.
    *   Toggle the completion status of subtasks.
    *   Delete subtasks.
*   **User Interface:**
    *   Responsive design for usability on various screen sizes (desktop, tablet, mobile).
    *   User-friendly interface for managing complex project structures.
    *   Loading states and error messages for backend interactions.
    *   Test button to check backend connectivity (`/hello` endpoint).

## Prerequisites

*   **Frontend:**
    *   [Node.js](https://nodejs.org/) (LTS version recommended, e.g., 18.x or later)
    *   `npm` (comes with Node.js) or `yarn`
*   **Backend:**
    *   A running backend server as per the [Backend API Specification](#backend-api-specification) provided below.
    *   (Example: Python 3.x, Flask, and any dependencies listed in the backend's `requirements.txt`)
*   **Docker (Optional, for containerized deployment):**
    *   [Docker Installed](https://docs.docker.com/get-docker/)

## Backend Setup & Running (Placeholder Instructions)

**Note:** The following are *example* instructions. Please replace these with the actual setup steps for your specific backend implementation if it differs.

1.  **Clone the Repository:**
    ```bash
    # If backend is in the same repository
    git clone <repository-url>
    cd <repository-name>
    ```
2.  **Navigate to Backend Directory:**
    ```bash
    cd backend_directory 
    # (Replace 'backend_directory' with the actual path to your backend code)
    ```
3.  **Install Dependencies:**
    (This assumes a Python/Flask backend; adjust for your backend technology)
    ```bash
    # Example: Create a virtual environment (optional but recommended)
    python -m venv venv
    source venv/bin/activate  # On Windows: venv\Scripts\activate

    # Example: Install dependencies
    pip install -r requirements.txt 
    ```
4.  **Initialize Database (if applicable):**
    (Your backend might have specific commands to set up the database)
    ```bash
    # Example: flask db init, flask db migrate, flask db upgrade
    ```
5.  **Run the Backend Server:**
    ```bash
    # Example for Flask
    flask run
    # Or for a simple Python script
    # python app.py
    ```
6.  **Verify Backend:**
    *   The backend server is typically expected to run on `http://localhost:5000`. This is the default target for the frontend's Vite proxy.
    *   You can test the `/hello` endpoint (e.g., by opening `http://localhost:5000/hello` in your browser or using the "Test Backend /hello" button in the frontend app) to ensure it's running correctly.

## Frontend Setup & Running

1.  **Navigate to Frontend Directory:**
    ```bash
    cd frontend
    ```
2.  **Install Dependencies:**
    Using npm:
    ```bash
    npm install
    ```
    Or using yarn:
    ```bash
    yarn install
    ```
3.  **Start the Development Server:**
    Using npm:
    ```bash
    npm run dev
    ```
    Or using yarn:
    ```bash
    yarn dev
    ```
4.  **Access the Application:**
    *   The application will typically be available at `http://localhost:5173` (Vite's default port).
    *   The frontend is configured to proxy API requests starting with `/api` and `/hello` to the backend server (assumed to be at `http://localhost:5000`). Ensure your backend is running and accessible at this address.

5.  **Build for Production (Optional):**
    Using npm:
    ```bash
    npm run build
    ```
    Or using yarn:
    ```bash
    yarn build
    ```
    This will create a `dist` folder in the `frontend` directory with the optimized static assets.

## Running with Docker

This section provides instructions for building and running the frontend application using Docker and Docker Compose. This is a recommended approach for creating portable environments and simplifying deployment.

### A. Building the Frontend Docker Image

These instructions explain how to build the Docker image for the frontend application. This process packages the React application and an Nginx server, configured to serve the application, into a portable Docker image.

#### Prerequisite

*   **Docker Installed:** Ensure Docker is installed and running on your system. You can find installation instructions for your operating system on the [official Docker website](https://docs.docker.com/get-docker/).

#### Build Command

1.  **Navigate to the Frontend Directory:**
    Open your terminal or command prompt and change your current directory to the `frontend` directory, where the `Dockerfile` is located.
    ```bash
    cd path/to/your-project/frontend 
    # Replace 'path/to/your-project/' with the actual path to your project root
    ```

2.  **Run the Docker Build Command:**
    Execute the following command to build the Docker image. This command:
    *   `docker build`: Invokes the Docker build process.
    *   `-t kanban-frontend:latest`: Tags the image with a name (`kanban-frontend`) and a tag (`latest`). You can customize these. Using a meaningful tag helps in managing different versions of your image.
    *   `.`: Specifies that the build context (the set of files Docker needs to build the image, including the `Dockerfile`) is the current directory.

    ```bash
    docker build -t kanban-frontend:latest .
    ```

#### Context

Running the `docker build` command executes the instructions defined in the `frontend/Dockerfile`. This multi-stage Dockerfile will:

*   **Stage 1 (Build Stage):**
    *   Use a Node.js environment to install all frontend dependencies (`npm install`).
    *   Build the React application for production (`npm run build`), creating optimized static assets in the `/app/dist` directory within the build stage.
*   **Stage 2 (Serve Stage):**
    *   Use an Nginx base image.
    *   Copy the static assets built in Stage 1 (from `/app/dist`) into Nginx's default HTML serving directory (`/usr/share/nginx/html`).
    *   Copy the custom `nginx.conf` file (also from the `frontend` directory) into Nginx's configuration directory, ensuring Nginx is set up to serve the Single Page Application correctly.

The result of this process is a Docker image named `kanban-frontend` (or your chosen name) with the tag `latest`. This image contains your compiled frontend application and a configured Nginx web server ready to serve it.

### B. Running the Standalone Frontend Container

Once you have built the `kanban-frontend:latest` Docker image, you can run it as a container.

#### 1. Basic Run Command

To run the frontend container, use the `docker run` command. This command starts your Nginx server, which serves the React application.

```bash
docker run -d -p 8080:80 --name kanban-frontend-container kanban-frontend:latest
```

*   `-d`: Runs the container in detached mode (in the background).
*   `-p 8080:80`: Maps port 8080 on your host machine to port 80 inside the container (Nginx serves on port 80 by default). You can change `8080` to any other available port on your host.
*   `--name kanban-frontend-container`: Assigns a recognizable name to your running container. This is optional but helpful for managing containers.
*   `kanban-frontend:latest`: Specifies the image to run.

After running this command, the frontend application should be accessible in your web browser at `http://localhost:8080` (or whichever host port you chose).

#### 2. Connecting to the Backend API

The frontend application needs to communicate with the backend API. The way this is configured depends on where your backend is running relative to your frontend Docker container.

**Important Note on `nginx.conf` for Standalone Mode:**
The current `nginx.conf` included in the frontend Docker image (from `frontend/nginx.conf`) has a Content Security Policy (CSP) header:
`Content-Security-Policy "default-src 'self'; ... connect-src 'self' http://localhost:5000;" always;`
This policy tells the user's browser that it's allowed to make requests (e.g., API calls) to `'self'` (the frontend's own origin) and `http://localhost:5000`.

*   **This means the frontend application, when running in the browser, will attempt to make API calls directly to `http://localhost:5000/api/...` (or `/hello`).**
*   For this to work, your backend API server must be running and accessible at `http://localhost:5000` **from the perspective of the user's machine/browser**, not from within the frontend Docker container.
*   If Nginx needs to act as a reverse proxy for API calls (e.g., to route calls from `http://localhost:8080/api` to a backend container on a shared Docker network), the `frontend/nginx.conf` file **must be modified** to include the appropriate `location /api/ { proxy_pass ... }` directives **before building the Docker image**. See the Docker Compose section for an example of such proxy configuration.

**Scenarios:**

*   **Scenario A: Backend Running Directly on Your Host Machine (e.g., during development)**
    *   If your backend server is running on your local machine and is listening on `localhost:5000` (or `0.0.0.0:5000`), the current CSP and the frontend's API calls will work as the browser can reach `http://localhost:5000`.
    *   No changes to the Docker run command or frontend configuration are strictly needed.

*   **Scenario B: Backend Running in Another Docker Container on the Same Docker Network**
    *   If your backend runs in a Docker container named, for example, `kanban-backend` and is on the same user-defined Docker network, the frontend container itself cannot directly use `http://kanban-backend:5000` for its API calls because these calls are made by the browser.
    *   **To make this work with the current `nginx.conf` CSP, you would need to:**
        1.  Ensure the `kanban-backend` container maps its port 5000 to `localhost:5000` on the host machine. For example, `docker run ... -p 5000:5000 kanban-backend`.
        2.  The frontend container can then be run as described in the "Basic Run Command". The browser will make requests to `http://localhost:5000/api/...`, which will hit the backend container via the host's port mapping.
    *   **Alternative (More Robust for Container-to-Container): Reverse Proxy with Nginx**
        Modify `frontend/nginx.conf` to include proxy pass rules (see Docker Compose section for details) and run containers on the same network. This is generally preferred for containerized environments.

*   **Scenario C: Backend is Publicly Accessible via a URL**
    *   If your backend is, for example, at `https://api.mykanban.com`, you would need to:
        1.  **Modify Frontend Code:** Change the API base URL in `frontend/src/services/api.js` to use this absolute URL.
        2.  **Update CSP:** Modify the `Content-Security-Policy` in `frontend/nginx.conf` to allow connections to `https://api.mykanban.com`.
        3.  Rebuild the frontend Docker image with these changes.

**Runtime Configuration of API URL (Recommended for Maximum Flexibility - Advanced)**
Refer to the previous subtask report for details on this advanced configuration. For the current setup, ensure your backend is accessible from the user's browser at `http://localhost:5000`.

#### 3. Accessing the Application

Once the container is running and your backend is accessible as described above:

*   Open your web browser.
*   Navigate to `http://localhost:8080` (or the host port you mapped in the `docker run` command).

#### 4. Stopping and Removing the Container

*   **To stop the container:**
    ```bash
    docker stop kanban-frontend-container
    ```
*   **To remove the container (after stopping):**
    ```bash
    docker rm kanban-frontend-container
    ```

### C. Using Docker Compose (Recommended for local development)

Docker Compose is a tool for defining and running multi-container Docker applications. It simplifies the management of the frontend and backend services, especially when they need to communicate with each other.

**Before you begin:**

*   **File Creation:** You will need to create a file named `docker-compose.yml` in the root directory of your project (the same directory that contains the `frontend` and likely your backend source folder or where you manage your backend image).
*   **Important Note on Container Naming and Existing Containers:** The `docker-compose.yml` defines *services* (e.g., `frontend`, `backend`). When you run `docker-compose up`, it will create *new* containers for these services. The `container_name` fields (e.g., `kanban-frontend`, `kanban-backend`) specify the names for these new containers managed by Docker Compose.
    If you have an existing standalone container (like `kanban-app-container` which you might have started with `docker run`), the services defined in Docker Compose are separate. The `backend` service in this `docker-compose.yml` will use the image `kanban-app:latest` to start a *new* container.
*   **Potential Port Conflicts:** If your existing standalone backend container (`kanban-app-container`) is already using host port 5000 (as might be the case if you followed earlier standalone run instructions for a backend), and the `backend` service in `docker-compose.yml` also maps to host port 5000 (e.g., `ports: - "5000:5000"`), you will encounter a port conflict. You should either:
    a. Stop your standalone container (e.g., `docker stop kanban-app-container`) before running `docker-compose up -d`.
    b. Change the host port mapping for the `backend` service in `docker-compose.yml` (e.g., to `ports: - "5001:5000"`) if you need both running, and adjust your access URLs accordingly.
    For this guide, we assume you will stop any conflicting standalone containers to allow Docker Compose to manage the backend service on port 5000.

#### 1. `docker-compose.yml` Example

This file orchestrates the deployment of both the frontend and backend services. Save this content as `docker-compose.yml` in the root of your project directory.

```yaml
version: '3.8'

services:
  frontend:
    build:
      context: ./frontend # Assumes Dockerfile is in ./frontend
      dockerfile: Dockerfile
    container_name: kanban-frontend
    ports:
      - "8080:80" # Expose frontend on host port 8080, mapping to container port 80
    depends_on:
      - backend
    # Environment variables are not directly used by Nginx in this basic setup.
    # Nginx configuration will be modified to proxy to the 'backend' service name.
    # See the modified nginx.conf section.
    # Example if frontend JavaScript needed to know the backend URL (not the case here as Nginx handles proxy):
    # environment:
    #   - REACT_APP_API_BASE_URL=http://localhost:8080/api # Browser sees this, Nginx proxies /api
    networks:
      - kanban-net

  backend:
    image: kanban-app:latest # !!! User should ensure this image is available (e.g., built locally or pulled) !!!
    container_name: kanban-backend
    ports:
      - "5000:5000" # Maps host port 5000 to container port 5000 (backend's default listening port)
    # Example environment variables for the backend (uncomment and adjust as needed)
    # environment:
    #   - DATABASE_URL=postgresql://user:password@db_host:5432/kanbandb
    #   - FLASK_ENV=development
    #   - SECRET_KEY=your_very_secret_key
    #   # Add any other environment variables your backend requires
    networks:
      - kanban-net
    # Example for persistent data if your backend uses a database (uncomment and adjust)
    # volumes:
    #   - backend_db_data:/var/lib/postgresql/data

networks:
  kanban-net:
    driver: bridge

# Example for persistent data volume (uncomment if used by backend)
# volumes:
#   backend_db_data:

```

#### 2. `nginx.conf` Modifications for Docker Compose Proxy

For Docker Compose to work seamlessly with service discovery (e.g., the frontend Nginx proxying to `http://backend:5000`), Nginx must act as a reverse proxy for API calls.

**Crucially, the `frontend/nginx.conf` file must be updated with these proxy configurations *before* you build the frontend Docker image using `docker build` or `docker-compose build`.** The `frontend/Dockerfile` copies this `nginx.conf` into the image during the build process.

The relevant part of your `frontend/nginx.conf` should be modified as follows:

```nginx
# Inside server { ... } block

    # Proxy API requests to the backend service
    location /api/ {
        proxy_pass http://backend:5000/api/; # 'backend' is the service name in docker-compose.yml
                                            # The port '5000' should match the port your backend service listens on *inside its container*.
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Proxy /hello requests to the backend service
    location = /hello { # Use '=' for exact match
        proxy_pass http://backend:5000/hello;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Serve static files (frontend application)
    location / {
        root /usr/share/nginx/html;
        index index.html index.htm;
        try_files $uri $uri/ /index.html; # Crucial for Single Page Applications
    }

    # Content Security Policy (CSP) Update for Proxied Environment:
    # If you have a CSP, ensure connect-src allows 'self' for proxied requests.
    # Example:
    # add_header Content-Security-Policy "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'self';" always;
    # This allows the browser to connect to its own origin ('self'), and Nginx handles forwarding to the backend.
```

**Explanation of `nginx.conf` changes:**
*   **`proxy_pass http://backend:5000/api/;`**:
    *   `backend`: This is the service name of your backend as defined in `docker-compose.yml`. Docker's internal DNS will resolve this to the backend container's IP address on the `kanban-net` network.
    *   `5000`: This is the port your backend application is listening on *inside its container*.
*   **CSP:** The `connect-src 'self';` directive in the CSP is appropriate when Nginx proxies all API calls, as the browser only ever communicates with the frontend's origin.

#### 3. Instructions for Use (Docker Compose)

1.  **Save Files:**
    *   Ensure the `docker-compose.yml` content is saved in the project root.
    *   Ensure `frontend/nginx.conf` has been updated with the proxy pass configurations as described above.
2.  **Modify Placeholders in `docker-compose.yml`:**
    *   **Crucial:** Ensure the `backend` service's `image` is set to `kanban-app:latest` (or your specific backend image name if different).
    *   Adjust backend `ports`, `environment` variables, and `volumes` as needed.
3.  **Start the Services:**
    *   Open your terminal, navigate to the project root (where `docker-compose.yml` is).
    *   Run:
        ```bash
        docker-compose up -d --build
        ```
        *   `--build`: Builds images before starting services (important for `frontend` if `nginx.conf` or frontend code changed).
        *   `-d`: Detached mode.
4.  **Accessing the Application:**
    *   Frontend: `http://localhost:8080`
5.  **Viewing Logs:**
    ```bash
    docker-compose logs -f
    # docker-compose logs -f frontend
    # docker-compose logs -f backend
    ```
6.  **Stopping the Services:**
    ```bash
    docker-compose down
    # Add -v to remove volumes: docker-compose down -v
    ```

---

## Deploying to a Cloud Server with Docker

This section provides guidance on deploying the containerized frontend application (and potentially the backend, if using Docker Compose) to a cloud server.

### Cloud Server Prerequisites

Before deploying the application to a cloud server using Docker, ensure the following prerequisites are met on your chosen cloud virtual machine (VM) or server instance:

1.  **Docker Engine:**
    *   Docker Engine must be installed on the cloud server's operating system. This is the core runtime that enables Docker containers to run.
    *   Official installation instructions can be found at: [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    *   The specific installation steps will vary depending on your server's Linux distribution (e.g., Ubuntu, CentOS, Debian) or operating system. Follow the guide relevant to your server's OS.

2.  **Docker Compose (if using `docker-compose.yml`):**
    *   If you plan to use the `docker-compose.yml` file provided in this guide to manage both frontend and backend services, you will need Docker Compose.
    *   It's recommended to use Docker Compose V2, which is typically included with Docker Desktop. For Linux servers, it's often installed as a plugin for Docker Engine.
    *   Official installation instructions can be found at: [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)

3.  **User Permissions for Docker (Optional but Recommended):**
    *   To run Docker commands without needing `sudo` for every command, it's common practice to add your server user to the `docker` group.
    *   You can do this with the command:
        ```bash
        sudo usermod -aG docker $USER
        ```
    *   **Important:** After running this command, you will likely need to start a new login session for this change to take effect (e.g., log out and log back in, or close and reopen your SSH session).

4.  **Cloud Provider Specifics:**
    *   Note that many cloud providers (AWS, Google Cloud, Azure, etc.) offer their own managed container services (e.g., Amazon ECS, Google Kubernetes Engine, Azure Kubernetes Service, Azure Container Instances) or provide VM images that come with Docker pre-installed. These can sometimes simplify the setup process.
    *   The prerequisites listed here assume you are setting up Docker on a generic cloud VM. If you are using a managed container service, refer to your cloud provider's documentation.

### Transferring Project Files to Cloud Server

To deploy your application using Docker on a cloud server, you first need to transfer the necessary project files from your local development environment to the server.

#### Required Files for Deployment

Ensure the following files and directories are present on your cloud server:

*   **`frontend/` directory:** The entire `frontend` directory is required. This includes:
    *   All frontend source code (React components, services, CSS, etc.).
    *   The `Dockerfile` located at `frontend/Dockerfile`.
    *   The Nginx configuration file `frontend/nginx.conf`.
*   **`docker-compose.yml` (if using Docker Compose):**
    *   This file should be placed in the project's root directory on the server (i.e., the parent directory of the `frontend` folder).

#### Method 1: Using `git clone` (Recommended)

If your project is hosted in a Git repository (e.g., on GitHub, GitLab, Bitbucket), this is generally the easiest and most common method. It also simplifies updates.

1.  **SSH into your cloud server:**
    ```bash
    ssh your_user@your_cloud_server_ip
    ```
    (Replace `your_user` and `your_cloud_server_ip` with your actual server username and IP address/hostname).

2.  **Clone your repository:**
    Navigate to the directory where you want to place your project (e.g., `/opt`, `/srv`, or your home directory) and then clone the repository.
    ```bash
    git clone <your_repository_url>
    ```
    (Replace `<your_repository_url>` with the actual URL of your Git repository).

3.  **Navigate into the project directory:**
    ```bash
    cd <project_directory_name>
    ```
    (Replace `<project_directory_name>` with the name of the directory created by `git clone`).

*   **Note:** If your backend code is in the same repository, it will also be cloned. This is usually the intended behavior for a full-stack deployment.

#### Method 2: Using `scp` (Secure Copy)

`scp` allows you to securely copy files and directories between your local machine and a remote server.

1.  **Copy the `frontend` directory (recursively):**
    From your *local machine's terminal*, run:
    ```bash
    scp -r /path/to/your/local/project/frontend your_user@your_cloud_server_ip:/path/to/remote/project_root/
    ```
    *   `-r`: Recursively copies directories.
    *   `/path/to/your/local/project/frontend`: The path to your local `frontend` directory.
    *   `your_user@your_cloud_server_ip:/path/to/remote/project_root/`: The destination path on your server. The `frontend` directory will be created inside `project_root`.

2.  **Copy the `docker-compose.yml` file:**
    From your *local machine's terminal*, run:
    ```bash
    scp /path/to/your/local/project/docker-compose.yml your_user@your_cloud_server_ip:/path/to/remote/project_root/
    ```
    *   `/path/to/your/local/project/docker-compose.yml`: The path to your local `docker-compose.yml` file.
    *   `your_user@your_cloud_server_ip:/path/to/remote/project_root/`: The destination path on your server where `docker-compose.yml` should reside.

#### Method 3: Using `rsync`

`rsync` is a versatile tool for synchronizing files and directories. It's particularly efficient for updates as it only transfers the differences.

1.  **Sync the `frontend` directory:**
    From your *local machine's terminal*, run:
    ```bash
    rsync -avz /path/to/your/local/project/frontend/ your_user@your_cloud_server_ip:/path/to/remote/project_root/frontend/
    ```
    *   `-a` (archive): Preserves permissions, ownership, timestamps, etc., and implies recursive.
    *   `-v` (verbose): Shows details of the transfer.
    *   `-z` (compress): Compresses file data during transfer.
    *   **Note the trailing slashes:**
        *   `/path/to/your/local/project/frontend/` (with slash): Copies the *contents* of the local `frontend` directory into the remote `frontend` directory.
        *   If you omit the trailing slash on the source (`.../frontend`), it would copy the `frontend` directory itself *into* the destination.

2.  **Sync the `docker-compose.yml` file:**
    From your *local machine's terminal*, run:
    ```bash
    rsync -avz /path/to/your/local/project/docker-compose.yml your_user@your_cloud_server_ip:/path/to/remote/project_root/docker-compose.yml
    ```

#### Choosing a Method

*   **`git clone`**: Preferred for projects under version control, especially if you plan to pull updates to the server regularly.
*   **`scp`**: Simple and effective for one-time copies or when Git is not used.
*   **`rsync`**: Excellent for initial transfers and very efficient for subsequent updates, as it minimizes data transfer. It's also good for more complex synchronization needs.

After transferring the files, you can proceed with building Docker images and running containers on your cloud server as described in the subsequent sections.

### Making the Docker Image Available on the Server

Once your project files are on the cloud server, you need to make the Docker images (especially `kanban-frontend:latest` and your backend image `kanban-app:latest`) available on that server.

Choose one of the following methods:

#### Option A: Build Image Directly on the Cloud Server

This is a straightforward method if your cloud server has enough resources (CPU, RAM, disk space) and the necessary build tools (like Node.js for the frontend, though the multi-stage Dockerfile for the frontend mitigates this by including Node in the build stage).

1.  **Ensure Project Files are Present:**
    Make sure you've transferred the `frontend` directory (containing the `Dockerfile` and `nginx.conf`) and any backend source code (if you're also building the backend image on the server) to your cloud server.
2.  **Build the Frontend Image:**
    Navigate to the `frontend` directory on your server and run the build command:
    ```bash
    cd /path/to/your-project/frontend
    docker build -t kanban-frontend:latest .
    ```
3.  **Build/Ensure Backend Image:**
    *   If you are also building your backend image on the server, navigate to your backend's source directory and use its `Dockerfile` to build it (e.g., `docker build -t kanban-app:latest .`).
    *   If you are using a pre-built backend image from a registry, you'll pull it later (see Option B or Docker Compose usage).

**Pros:**
*   Simplicity: Fewer steps if you're already on the server with the code.
*   No external Docker registry dependency for the build step.

**Cons:**
*   Resource Usage: Building images can be resource-intensive on the server.
*   Isolation: The image is only available on that specific server unless pushed to a registry.
*   Build Environment: May require build tools on the server (though the multi-stage frontend Dockerfile includes Node.js for its build stage).

#### Option B: Push to and Pull from a Docker Registry (Recommended)

This method is more robust, scalable, and common in CI/CD pipelines and production environments. It involves building the image on your local machine (or a dedicated build server) and then pushing it to a Docker registry. The cloud server then pulls the image from the registry.

**1. On Your Local Machine (or Build Server):**

*   **Build the Image(s):**
    *   Frontend: `cd frontend && docker build -t kanban-frontend:latest .`
    *   Backend: (If you build it from source) `cd backend_source_dir && docker build -t kanban-app:latest .`
*   **Log in to Your Docker Registry:**
    *   **Docker Hub:**
        ```bash
        docker login
        # Enter your Docker Hub username and password/access token
        ```
    *   **AWS ECR, Google GCR, Azure ACR, GitLab Registry, etc.:**
        Follow your specific registry provider's instructions for logging in via the Docker CLI. This often involves `aws ecr get-login-password`, `gcloud auth configure-docker`, or `az acr login`.
*   **Tag the Image(s) for the Registry:**
    Before pushing, you need to tag your image with the full registry path:
    ```bash
    # For frontend (replace <your_registry_user> with your Docker Hub username or full registry path)
    docker tag kanban-frontend:latest <your_registry_user>/kanban-frontend:latest

    # For backend (replace <your_registry_user> with your Docker Hub username or full registry path)
    docker tag kanban-app:latest <your_registry_user>/kanban-app:latest 
    ```
    *   Example for Docker Hub: `docker tag kanban-frontend:latest mydockerhubuser/kanban-frontend:latest`
    *   Example for AWS ECR: `docker tag kanban-frontend:latest 123456789012.dkr.ecr.us-east-1.amazonaws.com/kanban-frontend:latest`
*   **Push the Image(s) to the Registry:**
    ```bash
    # For frontend
    docker push <your_registry_user>/kanban-frontend:latest

    # For backend
    docker push <your_registry_user>/kanban-app:latest
    ```

**2. On Your Cloud Server:**

*   **Log in to the Docker Registry (if it's a private registry):**
    Use the same `docker login` command or provider-specific login method as on your local machine if you pushed to a private registry.
*   **Pull the Image(s) from the Registry:**
    ```bash
    # For frontend
    docker pull <your_registry_user>/kanban-frontend:latest

    # For backend
    docker pull <your_registry_user>/kanban-app:latest
    ```
*   **(Optional) Re-tag the Image for Local Use:**
    If you want to use simpler local tags (like `kanban-frontend:latest` or `kanban-app:latest` in your `docker-compose.yml` without the full registry path), you can re-tag the pulled image:
    ```bash
    # For frontend
    docker tag <your_registry_user>/kanban-frontend:latest kanban-frontend:latest

    # For backend
    docker tag <your_registry_user>/kanban-app:latest kanban-app:latest
    ```
    This step is often unnecessary if your `docker-compose.yml` uses the full image path from the registry.

**Pros:**
*   Image Consistency: The same image built and tested locally (or by CI) is deployed.
*   Build Offloading: Server resources are not used for building.
*   Versioning & Rollbacks: Registries make it easy to manage image versions and roll back if needed.
*   Scalability: Easy to deploy the same image to multiple servers.

**Cons:**
*   Requires a Docker registry (public or private).
*   More steps involved (tag, push, pull).

#### Choosing an Option

*   **Build on Server:** Might be acceptable for very simple, single-server deployments or quick tests where setting up a registry seems like overkill.
*   **Docker Registry:** Highly recommended for production, multi-server deployments, CI/CD integration, or when you want better image management and consistency.

The same principles apply to making your backend Docker image (`kanban-app:latest`) available on the server, especially if you are using Docker Compose, which will expect to find this image.

### Running the Frontend Container on the Cloud Server

Once the `kanban-frontend:latest` Docker image (and `kanban-app:latest` for the backend, if using Docker Compose) is available on your cloud server, you can run the application.

**Prerequisites:**

*   The Docker images (`kanban-frontend:latest` and, if applicable, `kanban-app:latest`) are present on the server (either built directly or pulled from a registry).
*   The `frontend/nginx.conf` file must be correctly configured **within the `kanban-frontend:latest` image** for how it will connect to the backend. This means if you need Nginx to proxy API requests, these changes should have been made to `frontend/nginx.conf` *before* the image was built.

#### A. Standalone Mode (`docker run` - Frontend Only)

This method runs only the frontend container. It requires careful consideration of how the frontend (served by Nginx in the container) will reach the backend API.

**Basic Command (assuming Nginx will serve on port 80 inside container):**

```bash
docker run -d -p 80:80 --name kanban-frontend-prod kanban-frontend:latest
```
*   `-p 80:80`: Maps port 80 on your host (cloud server) to port 80 inside the container. This makes your application accessible on the standard HTTP port. Adjust the host port if port 80 is already in use (e.g., `-p 8080:80`).
*   `--name kanban-frontend-prod`: A descriptive name for your production frontend container.

**Crucial: Backend API URL Configuration & `nginx.conf`**

Since the `nginx.conf` is baked into the `kanban-frontend:latest` image, its configuration for API proxying is fixed at build time.

*   **Scenario 1: Backend also Dockerized on the same server, connected via a Docker network (Recommended for co-located services):**
    1.  Create a Docker network: `docker network create my-app-network`
    2.  Run your backend container on this network: `docker run ... --network my-app-network --name actual-backend-container kanban-app:latest`
    3.  **Before building `kanban-frontend:latest`**, your `frontend/nginx.conf` must be configured to proxy to the backend container's service name and port on this network. Example:
        ```nginx
        # Inside frontend/nginx.conf, location /api/ block
        proxy_pass http://actual-backend-container:5000/api/; 
        # Replace 'actual-backend-container' if your backend container has a different name on the network.
        # Port 5000 is the port the backend listens on *inside its container*.
        ```
    4.  Build the `kanban-frontend:latest` image with this updated `nginx.conf`.
    5.  Run the frontend container on the same network: `docker run -d -p 80:80 --network my-app-network --name kanban-frontend-prod kanban-frontend:latest`

*   **Scenario 2: Backend running directly on the cloud server's host (not containerized), or in a container mapped directly to a host port:**
    *   If the backend is reachable at `http://<cloud_server_IP_or_localhost_equivalent>:5000` from *within* the frontend container's network namespace.
    *   Your `frontend/nginx.conf` (baked into the image) would need to `proxy_pass http://<host_ip_or_gateway_ip>:5000/api/;`. The exact IP to use can be tricky (e.g., `172.17.0.1` for default Docker bridge gateway, or a specific host IP). This is less portable.
    *   Alternatively, if the `nginx.conf` CSP allows `connect-src 'self' http://your_server_ip:5000;` and your backend is exposed on `your_server_ip:5000`, the browser could make direct calls, but this is less common for production setups.

*   **Scenario 3: Backend is on a different server/public URL:**
    *   Your `frontend/nginx.conf` (baked into the image) should be configured to `proxy_pass https://your.backend.api.domain.com/api/;`.
    *   Alternatively, if the frontend JavaScript directly calls the public API URL, the `nginx.conf` just needs to serve static files, and its CSP must allow connections to that public API domain.

**General Advice for Standalone `docker run`:** For standalone mode, it's often simpler if the `nginx.conf` is configured to point to an externally accessible backend URL (Scenario 3) or if the backend is also containerized and a reverse proxy setup (like Nginx proxying) is well-defined before building the frontend image.

#### B. Using Docker Compose (Recommended for co-located backend)

Docker Compose simplifies running multi-container applications, including the frontend and backend, and handles network creation and service discovery.

1.  **Ensure `docker-compose.yml` is Present:**
    Make sure your `docker-compose.yml` file (as described in the "Running with Docker" section) is on your cloud server, typically in your project's root directory.
2.  **Ensure `nginx.conf` is Correct for Proxying:**
    As detailed in the "Docker Compose" section of "Running with Docker", your `frontend/nginx.conf` **must be updated** to include the `proxy_pass http://backend:5000/...;` directives *before* the frontend image is built. The `backend` service name in `proxy_pass` refers to the backend service defined in your `docker-compose.yml`.
3.  **Navigate to Directory:**
    In your server's terminal, navigate to the directory containing your `docker-compose.yml` file.
4.  **Run Docker Compose:**
    ```bash
    docker-compose up -d --build
    ```
    *   `--build`: This is important to ensure the `kanban-frontend` image is built using the (potentially updated for proxying) `frontend/nginx.conf`.
    *   `-d`: Runs in detached mode.

**Explanation with Docker Compose:**
Docker Compose creates a default network (or uses the one specified, like `kanban-net`) and allows services to communicate using their service names. The `proxy_pass http://backend:5000/api/;` in `nginx.conf` works because Docker's internal DNS resolves `backend` to the IP address of the `backend` service's container on the shared Docker network. The port `5000` should be the port your backend application listens on *inside its container*.

#### Verifying the Deployment

1.  **Access via IP/Domain:**
    Open a web browser and navigate to your cloud server's public IP address or configured domain name (e.g., `http://your_cloud_server_ip` if you mapped to port 80, or `http://your_cloud_server_ip:8080` if you mapped to 8080).
2.  **Check Docker Logs:**
    *   **Standalone:** `docker logs kanban-frontend-prod` (and logs for your backend container if run separately).
    *   **Docker Compose:** `docker-compose logs -f frontend` and `docker-compose logs -f backend`.
    Look for any error messages.

### Firewall Configuration

Cloud servers and the operating systems running on them typically employ firewalls to control incoming and outgoing network traffic. By default, most firewalls block all incoming traffic unless explicitly allowed. For your Kanban application to be accessible from the internet, you need to configure the firewall to allow traffic on the port your frontend is exposed on.

*   If you mapped your frontend container to port 80 (e.g., `docker run -p 80:80 ...` or `ports: - "80:80"` in `docker-compose.yml`), you'll need to allow HTTP traffic.
*   If you later set up HTTPS, you'll need to allow traffic on port 443.

There are generally two layers of firewalls to consider:

#### 1. Cloud Provider Firewalls

Most cloud providers (e.g., AWS, Google Cloud, Azure) have their own network firewall systems:

*   **AWS:** Security Groups
*   **Google Cloud:** VPC Firewall Rules
*   **Azure:** Network Security Groups (NSGs)

These are configured through the cloud provider's web console or CLI. You must ensure that these provider-level firewalls allow incoming traffic on the necessary ports (e.g., 80 for HTTP, 443 for HTTPS) to your server instance. Consult your specific cloud provider's documentation for instructions on how to manage these rules.

#### 2. Linux Server Firewalls (e.g., `ufw` for Ubuntu)

In addition to the cloud provider's firewall, the server's operating system often has its own firewall software. For Ubuntu servers, `ufw` (Uncomplicated Firewall) is commonly used.

Here are common `ufw` commands:

1.  **Check `ufw` Status:**
    See if `ufw` is active and view existing rules.
    ```bash
    sudo ufw status
    ```
    If it's inactive, you might see `Status: inactive`.

2.  **Allow SSH (Crucial!):**
    **Before enabling `ufw` for the first time, ensure SSH access is allowed to prevent losing remote access to your server.**
    ```bash
    sudo ufw allow OpenSSH 
    # 'OpenSSH' is a predefined application profile. Alternatively, use the port number:
    # sudo ufw allow 22/tcp 
    ```

3.  **Enable `ufw` (if inactive):**
    If `ufw` is inactive, enable it. This will start enforcing the rules.
    ```bash
    sudo ufw enable
    ```
    It will prompt for confirmation. If you haven't allowed SSH, **this command could disconnect your current SSH session if SSH traffic isn't already permitted.**

4.  **Allow HTTP (Port 80):**
    To allow incoming traffic for your web application served over HTTP:
    ```bash
    sudo ufw allow 80/tcp
    # Or, using the service name:
    # sudo ufw allow http
    ```

5.  **Allow HTTPS (Port 443 - for future use):**
    If you plan to set up HTTPS later (recommended for production):
    ```bash
    sudo ufw allow 443/tcp
    # Or, using the service name:
    # sudo ufw allow https
    ```

6.  **Reload or Re-enable `ufw`:**
    After adding or changing rules, reload `ufw` to apply them:
    ```bash
    sudo ufw reload
    ```
    If you just enabled `ufw` using `sudo ufw enable`, the rules are typically applied automatically.

7.  **List Current Rules:**
    To see a numbered list of current rules:
    ```bash
    sudo ufw status numbered
    ```
    This is useful if you need to delete a specific rule by its number (e.g., `sudo ufw delete 1`).

#### Important Considerations:

*   **Order Matters:** Firewall rules are often processed in order. Ensure your "allow" rules are correctly placed, especially if you have more complex "deny" rules.
*   **Security Best Practices:** Only open the ports that are absolutely necessary.
*   **SSH Access:** Always double-check your SSH allow rule (`OpenSSH` or `22/tcp`) before enabling or modifying `ufw` rules to avoid locking yourself out of the server. If you do get locked out, you might need to use your cloud provider's console access or recovery options.
*   **Both Firewalls:** Remember that traffic might need to be allowed at *both* the cloud provider firewall level and the server OS firewall level (like `ufw`).

Proper firewall configuration is critical for making your application accessible and securing your server.

### Production Considerations: Domain Name and HTTPS

While the previous sections guide you on deploying the application to a cloud server using Docker, a production-ready setup typically involves additional steps for professionalism, security, and usability.

#### 1. Domain Name

Currently, you would access your application via the cloud server's IP address (e.g., `http://your_cloud_server_ip:8080`). For a professional and user-friendly experience, you'll want to use a custom domain name (e.g., `www.yourkanbanapp.com`).

This process generally involves:

*   **Registering a Domain Name:**
    *   You need to purchase a domain name from a domain name registrar (e.g., GoDaddy, Namecheap, Google Domains, Cloudflare Registrar, etc.).
*   **Configuring DNS Records:**
    *   Once you have a domain, you'll need to configure its DNS (Domain Name System) records through your registrar or DNS provider.
    *   Typically, this means creating an **'A' record** that points your domain (or a subdomain like `app.yourdomain.com`) to your cloud server's public IP address.
    *   DNS changes can take some time to propagate globally (from a few minutes to 48 hours).

#### 2. HTTPS (SSL/TLS Certificates)

Serving your application over **HTTPS** is crucial for security. HTTPS encrypts the data exchanged between your users' browsers and your server, protecting sensitive information and verifying the server's authenticity.

*   **Nginx for HTTPS:** The Nginx server already configured in your `frontend` Docker container is capable of handling HTTPS/SSL termination.
*   **Let's Encrypt:** A popular and free way to obtain SSL/TLS certificates is by using [Let's Encrypt](https://letsencrypt.org/), which is a free, automated, and open Certificate Authority (CA).
*   **Certbot:** The [Certbot](https://certbot.eff.org/) tool can automate the process of obtaining certificates from Let's Encrypt and configuring Nginx to use them. It can also handle certificate renewals.

Setting up HTTPS with Nginx and Let's Encrypt typically involves:

1.  **Installing Certbot:** Usually installed on the host cloud server (or potentially run from a dedicated Docker container).
2.  **Obtaining a Certificate:** Running Certbot with its Nginx plugin (or webroot plugin) to request and validate a certificate for your domain.
3.  **Configuring Nginx for SSL:**
    *   Modifying your `frontend/nginx.conf` to:
        *   Listen on port 443 for SSL connections (`listen 443 ssl;`).
        *   Specify the paths to your SSL certificate (`ssl_certificate`) and private key (`ssl_certificate_key`) provided by Certbot.
        *   Configure recommended SSL/TLS protocols and ciphers.
        *   Optionally, set up a redirect from HTTP (port 80) to HTTPS (port 443).
    *   **Important:** If you modify `nginx.conf`, you'll need to rebuild your `kanban-frontend` Docker image. Alternatively, for more advanced setups, SSL certificates and the updated Nginx configuration can be mounted into the running container from the host server.
4.  **Firewall Update:** Ensure your firewall (both cloud provider and server OS like `ufw`) allows incoming traffic on port 443 (HTTPS).

#### Out of Scope for This Guide

Detailed instructions for DNS configuration, registering domain names, and the full process of setting up HTTPS/SSL with Let's Encrypt and Nginx are extensive and can vary based on your specific domain registrar, cloud provider, and server OS.

These steps are considered **essential next steps for any production deployment** but are beyond the scope of this initial deployment guide.

We recommend searching for specific guides such as:
*   "How to point a domain name to my cloud server IP"
*   "Secure Nginx with Let's Encrypt on [Your Server OS, e.g., Ubuntu]"
*   "Let's Encrypt Docker Nginx" (for container-focused setups)

These resources will provide more in-depth, step-by-step instructions tailored to various environments.

---

## Backend API Specification

The original content of the README started here. It has been preserved below.

All API endpoints are prefixed with `/api`. Timestamps in responses are in ISO8601 format ending with 'Z' to denote UTC (e.g., `YYYY-MM-DDTHH:MM:SS.ffffffZ`).

### Projects

#### 1. Get All Projects

-   **Method:** `GET`
-   **Endpoint:** `/api/projects`
-   **Description:** Retrieves a list of all projects, ordered by creation date (newest first).
-   **Request Body:** None
-   **Success Response (200 OK):**
    ```json
    [
        {
            "id": "project_uuid_1",
            "name": "Project Alpha",
            "description": "This is project Alpha.",
            "created_at": "2023-10-01T10:00:00.123456Z",
            "updated_at": "2023-10-01T10:05:00.654321Z"
        },
        {
            "id": "project_uuid_2",
            "name": "Project Beta",
            "description": null,
            "created_at": "2023-09-25T15:30:00.000000Z",
            "updated_at": "2023-09-25T15:30:00.000000Z"
        }
    ]
    ```
-   **Error Response (500 Internal Server Error):**
    ```json
    {
        "error": "Failed to retrieve projects due to an internal server error"
    }
    ```

#### 2. Create a New Project

-   **Method:** `POST`
-   **Endpoint:** `/api/projects`
-   **Description:** Creates a new project.
-   **Request Body:**
    ```json
    {
        "name": "New Project Name", // String, Required
        "description": "Optional project description" // String, Optional
    }
    ```
-   **Success Response (201 Created):**
    ```json
    {
        "id": "new_project_uuid",
        "name": "New Project Name",
        "description": "Optional project description",
        "created_at": "2023-10-02T12:00:00.000000Z",
        "updated_at": "2023-10-02T12:00:00.000000Z"
    }
    ```
-   **Error Responses:**
    -   `400 Bad Request` (e.g., missing `name`):
        ```json
        {
            "error": "Project name (name) is required"
        }
        ```
    -   `409 Conflict` (project name already exists):
        ```json
        {
            "error": "Project name \"New Project Name\" already exists"
        }
        ```
    -   `500 Internal Server Error`:
        ```json
        {
            "error": "Failed to create project due to an internal server error"
        }
        ```

#### 3. Get Single Project Details

-   **Method:** `GET`
-   **Endpoint:** `/api/projects/<string:project_id>`
-   **Description:** Retrieves details for a specific project, including its stages, tasks, and subtasks, all sorted by their `order` attribute.
-   **Path Parameters:**
    -   `project_id` (String): The unique ID of the project.
-   **Success Response (200 OK):**
    ```json
    {
        "id": "project_uuid",
        "name": "Project Name",
        "description": "Project description",
        "created_at": "2023-10-01T10:00:00.123456Z",
        "updated_at": "2023-10-01T10:05:00.654321Z",
        "stages": [
            {
                "id": "stage_uuid_1",
                "name": "To Do",
                "project_id": "project_uuid",
                "order": 0,
                "created_at": "2023-10-01T10:01:00.000000Z",
                "updated_at": "2023-10-01T10:01:00.000000Z",
                "tasks": [
                    {
                        "id": "task_uuid_1_1",
                        "content": "Design homepage",
                        "stage_id": "stage_uuid_1",
                        "assignee": "Alice",
                        "start_date": "2023-10-05",
                        "end_date": "2023-10-10",
                        "order": 0,
                        "created_at": "2023-10-01T10:02:00.000000Z",
                        "updated_at": "2023-10-01T10:02:00.000000Z",
                        "subtasks": [
                            {
                                "id": "subtask_uuid_1_1_1",
                                "content": "Draft wireframes",
                                "parent_task_id": "task_uuid_1_1",
                                "completed": true,
                                "order": 0,
                                "created_at": "2023-10-01T10:03:00.000000Z",
                                "updated_at": "2023-10-01T10:04:00.000000Z"
                            }
                        ]
                    }
                ]
            }
            // ... other stages sorted by order
        ]
    }
    ```
-   **Error Responses:**
    -   `404 Not Found`:
        ```json
        {
            "error": "Project not found"
        }
        ```
    -   `500 Internal Server Error`.

#### 4. Update a Project

-   **Method:** `PUT`
-   **Endpoint:** `/api/projects/<string:project_id>`
-   **Description:** Updates an existing project's information.
-   **Path Parameters:**
    -   `project_id` (String): The unique ID of the project.
-   **Request Body:**
    ```json
    {
        "name": "Updated Project Name", // String, Optional
        "description": "Updated project description" // String, Optional (can be null or empty)
    }
    ```
-   **Success Response (200 OK):**
    ```json
    {
        "id": "project_uuid",
        "name": "Updated Project Name",
        "description": "Updated project description",
        "created_at": "2023-10-01T10:00:00.123456Z",
        "updated_at": "2023-10-02T14:30:00.000000Z"
    }
    ```
-   **Error Responses:**
    -   `400 Bad Request` (e.g., request body is empty, or `name` provided as empty string):
        ```json
        {
            "error": "Request body cannot be empty. Please provide 'name' and/or 'description'."
        }
        // or
        {
            "error": "Project name cannot be an empty string if provided"
        }
        ```
    -   `404 Not Found` (project not found).
    -   `409 Conflict` (new name conflicts with another project):
        ```json
        {
            "error": "Project name \"Updated Project Name\" is already used by another project"
        }
        ```
    -   `500 Internal Server Error`.

#### 5. Delete a Project

-   **Method:** `DELETE`
-   **Endpoint:** `/api/projects/<string:project_id>`
-   **Description:** Deletes a project and all its associated stages, tasks, and subtasks.
-   **Path Parameters:**
    -   `project_id` (String): The unique ID of the project.
-   **Success Response (200 OK):**
    ```json
    {
        "message": "Project successfully deleted"
    }
    ```
-   **Error Responses:**
    -   `404 Not Found` (project not found).
    -   `500 Internal Server Error`.

### Stages

#### 1. Create a New Stage for a Project

-   **Method:** `POST`
-   **Endpoint:** `/api/projects/<string:project_id>/stages`
-   **Description:** Creates a new stage within the specified project. New stages are appended to the end of the existing stages list (highest order).
-   **Path Parameters:**
    -   `project_id` (String): The unique ID of the parent project.
-   **Request Body:**
    ```json
    {
        "name": "New Stage Name" // String, Required
    }
    ```
-   **Success Response (201 Created):**
    ```json
    {
        "id": "new_stage_uuid",
        "name": "New Stage Name",
        "project_id": "project_uuid",
        "order": 2, // Example: if there were already stages with order 0 and 1
        "created_at": "2023-10-02T15:00:00.000000Z",
        "updated_at": "2023-10-02T15:00:00.000000Z",
        "tasks": [] // Tasks list is empty on creation
    }
    ```
-   **Error Responses:**
    -   `400 Bad Request` (e.g., missing `name`):
        ```json
        {
            "error": "Stage name (name) is required"
        }
        ```
    -   `404 Not Found` (project not found).
    -   `500 Internal Server Error`.

#### 2. Update a Stage

-   **Method:** `PUT`
-   **Endpoint:** `/api/stages/<string:stage_id>`
-   **Description:** Updates an existing stage's information (name, order).
-   **Path Parameters:**
    -   `stage_id` (String): The unique ID of the stage.
-   **Request Body:**
    ```json
    {
        "name": "Updated Stage Name", // String, Optional
        "order": 1 // Integer, Optional
    }
    ```
-   **Success Response (200 OK):**
    ```json
    {
        "id": "stage_uuid",
        "name": "Updated Stage Name",
        "project_id": "project_uuid",
        "order": 1,
        "created_at": "2023-10-01T10:01:00.000000Z",
        "updated_at": "2023-10-02T16:00:00.000000Z",
        "tasks": [/* ... existing tasks ... */]
    }
    ```
-   **Error Responses:**
    -   `400 Bad Request` (e.g., request body empty, name is empty string, order not integer):
        ```json
        {
            "error": "Request body cannot be empty. Please provide 'name' and/or 'order'."
        }
        // or
        {
            "error": "Stage name cannot be an empty string if provided"
        }
        // or
        {
            "error": "Order must be an integer"
        }
        ```
    -   `404 Not Found` (stage not found).
    -   `500 Internal Server Error`.

#### 3. Delete a Stage

-   **Method:** `DELETE`
-   **Endpoint:** `/api/stages/<string:stage_id>`
-   **Description:** Deletes a stage and all its associated tasks and subtasks.
-   **Path Parameters:**
    -   `stage_id` (String): The unique ID of the stage.
-   **Success Response (200 OK):**
    ```json
    {
        "message": "Stage successfully deleted"
    }
    ```
-   **Error Responses:**
    -   `404 Not Found` (stage not found).
    -   `500 Internal Server Error`.

### Tasks

#### 1. Create a New Task for a Stage

-   **Method:** `POST`
-   **Endpoint:** `/api/stages/<string:stage_id>/tasks`
-   **Description:** Creates a new task within the specified stage. New tasks are appended to the end of the existing tasks list for that stage.
-   **Path Parameters:**
    -   `stage_id` (String): The unique ID of the parent stage.
-   **Request Body:**
    ```json
    {
        "content": "New task description", // String, Required
        "assignee": "User Name", // String, Optional
        "start_date": "YYYY-MM-DD", // String (Date format), Optional
        "end_date": "YYYY-MM-DD" // String (Date format), Optional
    }
    ```
-   **Success Response (201 Created):**
    ```json
    {
        "id": "new_task_uuid",
        "content": "New task description",
        "stage_id": "stage_uuid",
        "assignee": "User Name",
        "start_date": "2023-10-05",
        "end_date": "2023-10-10",
        "order": 1, // Example: if there was already a task with order 0
        "created_at": "2023-10-02T17:00:00.000000Z",
        "updated_at": "2023-10-02T17:00:00.000000Z",
        "subtasks": []
    }
    ```
-   **Error Responses:**
    -   `400 Bad Request` (e.g., missing `content`, invalid date format):
        ```json
        {
            "error": "Task content (content) is required"
        }
        // or
        {
            "error": "Invalid start_date format. Use YYYY-MM-DD."
        }
        ```
    -   `404 Not Found` (stage not found).
    -   `500 Internal Server Error`.

#### 2. Update a Task

-   **Method:** `PUT`
-   **Endpoint:** `/api/tasks/<string:task_id>`
-   **Description:** Updates an existing task's information (content, assignee, dates, order, or moves to a different stage).
-   **Path Parameters:**
    -   `task_id` (String): The unique ID of the task.
-   **Request Body:**
    ```json
    {
        "content": "Updated task content", // String, Optional
        "assignee": "New Assignee", // String, Optional (can be null)
        "start_date": "YYYY-MM-DD", // String (Date format), Optional (can be null)
        "end_date": "YYYY-MM-DD", // String (Date format), Optional (can be null)
        "order": 0, // Integer, Optional
        "stage_id": "new_stage_uuid" // String, Optional (to move task)
    }
    ```
-   **Success Response (200 OK):**
    ```json
    {
        "id": "task_uuid",
        "content": "Updated task content",
        "stage_id": "new_stage_uuid",
        "assignee": "New Assignee",
        "start_date": "2023-10-06",
        "end_date": "2023-10-12",
        "order": 0,
        "created_at": "2023-10-01T10:02:00.000000Z",
        "updated_at": "2023-10-02T18:00:00.000000Z",
        "subtasks": [/* ... existing subtasks ... */]
    }
    ```
-   **Error Responses:**
    -   `400 Bad Request` (e.g., empty body, empty content string, invalid date, invalid order):
        ```json
        {
            "error": "Request body cannot be empty. Please provide fields to update."
        }
        // or
        {
            "error": "Task content cannot be an empty string if provided"
        }
        ```
    -   `404 Not Found` (task not found, or target `stage_id` not found).
    -   `500 Internal Server Error`.

#### 3. Delete a Task

-   **Method:** `DELETE`
-   **Endpoint:** `/api/tasks/<string:task_id>`
-   **Description:** Deletes a task and all its associated subtasks.
-   **Path Parameters:**
    -   `task_id` (String): The unique ID of the task.
-   **Success Response (200 OK):**
    ```json
    {
        "message": "Task successfully deleted"
    }
    ```
-   **Error Responses:**
    -   `404 Not Found` (task not found).
    -   `500 Internal Server Error`.

### SubTasks

#### 1. Create a New SubTask for a Parent Task

-   **Method:** `POST`
-   **Endpoint:** `/api/tasks/<string:parent_task_id>/subtasks`
-   **Description:** Creates a new subtask under the specified parent task. New subtasks are appended to the end of the existing subtasks list for that parent.
-   **Path Parameters:**
    -   `parent_task_id` (String): The unique ID of the parent task.
-   **Request Body:**
    ```json
    {
        "content": "New subtask details", // String, Required
        "completed": false // Boolean, Optional, Defaults to false
    }
    ```
-   **Success Response (201 Created):**
    ```json
    {
        "id": "new_subtask_uuid",
        "content": "New subtask details",
        "parent_task_id": "parent_task_uuid",
        "completed": false,
        "order": 0, // Example: if this is the first subtask
        "created_at": "2023-10-02T19:00:00.000000Z",
        "updated_at": "2023-10-02T19:00:00.000000Z"
    }
    ```
-   **Error Responses:**
    -   `400 Bad Request` (e.g., missing `content`, `completed` is not boolean):
        ```json
        {
            "error": "Subtask content (content) is required"
        }
        // or
        {
            "error": "Completed status must be a boolean"
        }
        ```
    -   `404 Not Found` (parent task not found).
    -   `500 Internal Server Error`.

#### 2. Update a SubTask

-   **Method:** `PUT`
-   **Endpoint:** `/api/subtasks/<string:subtask_id>`
-   **Description:** Updates an existing subtask's information (content, completion status, order).
-   **Path Parameters:**
    -   `subtask_id` (String): The unique ID of the subtask.
-   **Request Body:**
    ```json
    {
        "content": "Updated subtask details", // String, Optional
        "completed": true, // Boolean, Optional
        "order": 1 // Integer, Optional
    }
    ```
-   **Success Response (200 OK):**
    ```json
    {
        "id": "subtask_uuid",
        "content": "Updated subtask details",
        "parent_task_id": "parent_task_uuid",
        "completed": true,
        "order": 1,
        "created_at": "2023-10-01T10:03:00.000000Z",
        "updated_at": "2023-10-02T20:00:00.000000Z"
    }
    ```
-   **Error Responses:**
    -   `400 Bad Request` (e.g., empty body, empty content string, invalid `completed`, invalid `order`):
        ```json
        {
            "error": "Request body cannot be empty"
        }
        // or
        {
            "error": "Subtask content cannot be empty"
        }
        ```
    -   `404 Not Found` (subtask not found).
    -   `500 Internal Server Error`.

#### 3. Delete a SubTask

-   **Method:** `DELETE`
-   **Endpoint:** `/api/subtasks/<string:subtask_id>`
-   **Description:** Deletes a subtask.
-   **Path Parameters:**
    -   `subtask_id` (String): The unique ID of the subtask.
-   **Success Response (200 OK):**
    ```json
    {
        "message": "SubTask successfully deleted" 
    }
    ```
-   **Error Responses:**
    -   `404 Not Found` (subtask not found).
    -   `500 Internal Server Error`.

### Test Interface

#### 1. Hello World

-   **Method:** `GET`
-   **Endpoint:** `/hello`
-   **Description:** A simple test route to check if the backend service is running.
-   **Success Response (200 OK):**
    ```text
    你好，看板后端已启动！(Hello, Kanban Backend is Running!)
    ```
